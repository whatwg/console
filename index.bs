<pre class="metadata">
Title: Console Standard
Group: WHATWG
H1: Console
Shortname: console
Level: 1
Status: DREAM
ED: https://terinjokes.github.io/console-spec
Editor: Terin Stock, https://terinstock.com, terin@terinstock.com
Abstract: This specification standardizes APIs for console debugging facilities.
Logo: https://cdn.rawgit.com/terinjokes/console-spec/dd485319b0d0c918d954e0daafd349c9387c6e8c/logo.svg
!Version History: <a href="https://github.com/terinjokes/console-spec/commits">https://github.com/terinjokes/console-spec/commits</a>
!Participate: <a href="https://github.com/terinjokes/console-spec/issues/new">File an issue</a> (<a href="https://github.com/terinjokes/console-spec/issues?state=open">open issues</a>)
!Participate: Send feedback to <a href="http://www.whatwg.org/mailing-list">whatwg@whatwg.org</a> (<a href="http://www.whatwg.org/mailing-list#specs">archives</a>)
!Participate: <a href="http://wiki.whatwg.org/wiki/IRC">IRC: #whatwg on Freenode</a>
Opaque Elements: emu-alg
</pre>

<style>
  .note + .example, .note + .note { margin-top: 1em; }

  emu-val { font-weight: bold; }
  emu-alg > ol, emu-alg > ol ol ol ol { list-style-type: decimal; }
  emu-alg > ol ol, emu-alg > ol ol ol ol ol { list-style-type: lower-alpha; }
  emu-alg > ol ol ol, emu-alg > ol ol ol ol ol ol { list-style-type: lower-roman; }
  emu-alg li { margin: 0; }

  .heading[aoid] .annotation {
    background-color: beige;
    border: 1px solid black;
    border-radius: 3px;
    cursor: help;
    display: inline-block;
    font-size: 70%;
    font-weight: normal;
    padding: 1px 2px;
  }
</style>

<h2 id="status" class="no-num no-toc">Status</h2>
This specification is in the process of establishing itself in the WHATWG.
As such, the term "Living Standard" indicates a goal, rather than reality.

Please join us in the <a href="https://github.com/terinjokes/console-spec/issues?state=open">issue tracker</a> for more discussion.

<h2 id="logger-function">Logger Function</h2>
The logging function accepts datum and the logLevel, which is stored or displayed in a platform appropriate way.

Each call of the Logger function prints a line which is ended by a newline.
If the Logger function is called with no arguments, no output is written to the console.
If the printing function gets multiple elements, it prints them separated by a space. It is possible to pass format specifiers to the function as the element of the arguments that should get printed.

The Logger(logLevel, multipleArgs) function must run these steps:

<emu-alg>
  1. Let _firstElement_ be the first element of _multipleArgs_.
  1. Let _rest_ be all elements following _firstElement_ in _multipleArgs_.
  1. Let _formatter_ be a recursive function.
  1. If no _firstElement_ given, do not print any output. Abort these steps.
  1. If just _firstElement_ given, print _firstElement_ to the console. Abort these steps.
  1. If _firstElement_ does not contain any format specifier, print _multipleArgs_ separated by one space to the console. Abort these steps.
  1. Call _formatter_ with _multipleArgs_:
    1. Let _target_ be the first element of _multipleArgs_.
    1. Let _current_ be the second element of _multipleArgs_.
    1. Find the first possible format specifier from the left to the right in _target_.
      1. If it is `%s`, let _converted_ be the result of new String(_current_).
      1. If it is `%d` or `%i`, let _converted_ be the result of Number.parseInt(_current_, 10).
      1. If it is `%f`, let _converted_ be the result of  Number.parseFloat(_current_, 10).
      1. Replace _current_ in _target_ with _converted_.
      1. Create _result_ which contains _target_ together with the elements of _multipleArgs_, but with _current_ removed.
    1. If _target_ does not have any format specifiers left, return _result_ and end the recursive function. Print the result. Abort the steps.
    1. If _result_ is just one element, return _result_ and end the recursive function. Print the result. Abort the steps.
    1. Call _formatter_ with _result_ until it returns.
</emu-alg>

<h3 id="nodejs-print">Side effects of the Logger Function</h3>

<div class="example">
  The simplest way to implement the side effects of the Logger Function on the Node.js platform is to join the previously formatted arguments separated by a space and write the output to `stdout` or `stderr`.

  Example implementation in Node.js:

  <pre><code class="lang-javascript">
    const util = require('util');
    function print(logLevel, ...args) {

      const message = util.format.apply(this, args);

      if (logLevel === 'error') {
        process.stderr.write(message + '\n');
        return;
      }

      if (logLevel === 'log' || logLevel === 'info' || logLevel === 'warn') {
        process.stdout.write(message + '\n');
        return;
      }
    }
  </code></pre>

  If the arguments contains nested objects they should get stringified. All other types that are not a String should get converted in their readable version, i.e. *undefined* gets the String `undefined` and *false* gets `false`.
</div>

<h2 id="console-interface">Interface <code>Console</code></h2>

<pre class="idl">
[NoInterfaceObject]
interface Console {
  // Logging
  void assert(boolean condition, optional any message);
  void clear();
  void count(optional DOMString label = "");
  void debug(any... data);
  void error(any... data);
  void info(any... data);
  void log(any... data);
  void table(any tabularData, optional sequence&lt;DOMString> properties);
  void trace(any... data);
  void warn(any... data);

  // Grouping
  void group(any... data);
  void groupCollapse(any... data);
  void groupEnd();

  // Timing
  void time(DOMString label);
  void timeEnd(DOMString label);
};

partial interface Window {
  attribute Console console;
};

partial interface WorkerGlobalScope {
  attribute Console console;
};
</pre>

<h3 id="logging">Logging Methods</h3>

<h4><dfn method for="Console">assert()</dfn></h4>
If expression is false, the side effect of running the logger function with the message as data, and the logLevel set to error.

<h4><dfn method for="Console">clear()</dfn></h4>
If possible for the environment, clear the console. Otherwise, do nothing.

<h4><dfn method for="Console">count()</dfn></h4>
Counts the number of times count has been called with the provided label.

<h4><dfn method for="Console">debug()</dfn></h4>

The side effect of running the logger function with data and logLevel set to log. Perform the side effects given by Logger("debug", data).

<h4><dfn method for="Console">error()</dfn></h4>

The side effect of running the logger function with data and logLevel set to error. Perform the side effects given by Logger("error", data).

<h4><dfn method for="Console">info()</dfn></h4>

The side effect of running the logger function with data and logLevel set to info. Perform the side effects given by Logger("info", data).

<h4><dfn method for="Console">log()</dfn></h4>

The side effect of running the logger function with data and logLevel set to info. Perform the side effects given by Logger("log", data).

<h4><dfn method for="Console">table()</dfn></h4>

Try to construct a table with the columns of the properties of tabularData and rows of tabularData and log it with a logLevel of log.
Fall back to just logging the argument if it can't be parsed as tabular.

TODO: This will need a good algorithm.

<h4><dfn method for="Console">trace()</dfn></h4>

The side effect of running the logger function with data and logLevel set to error.

<h4><dfn method for="Console">warn()</dfn></h4>

The side effect of running the logger function with data and logLevel set to warn.

<h3 id="grouping">Grouping Methods</h3>

<h4><dfn method for="Console">group()</dfn></h4>

<h4><dfn method for="Console">groupCollapse()</dfn></h4>

<h4><dfn method for="Console">groupEnd()</dfn></h4>

<h3 id="timing">Timing Methods</h3>

<h4><dfn method for="Console">time()</dfn></h4>

Start an internal timer stored in the timer table as label.

<h4><dfn method for="Console">timeEnd()</dfn></h4>

Store the current value of the internal timer stored as label as duration.
Remove the timer from tha timer table.
Then, the side effect of running the logger function with arguments label and duration.

<h2 id="formatting">Formatting Specifiers</h2>

<h3 id="formatting-no-ui">Formatting Specifiers that don't require a complex UI</h3>

<table>
  <thead>
    <tr>
      <th>Specifier</th>
      <th>Function</th>
      <th>Type Conversion</th>
    </tr>
  </thead>
  <tr>
  <tr>
    <td>%s</td>
    <td>Element which substitutes is converted to a String</<td>
    <td>new String(element)</td>
  </tr>
  <tr>
    <td>%d</td>
    <td>Element which substitutes is converted to an Integer</<td>
    <td>Number.parseInt(element, 10)</td>
  </tr>
  <tr>
    <td>%i</td>
    <td>Element which substitutes is converted to an Integer</<td>
    <td>Number.parseInt(element, 10)</td>
  </tr>
  <tr>
    <td>%f</td>
    <td>Element which substitutes is converted to a Float</<td>
    <td>Number.parseFloat(element, 10)</td>
  </tr>
</table>

<h3 id="formatting-no-ui">Formatting Specifiers that require a complex UI</h3>

<table>
  <thead>
    <tr>
      <th>Specifier</th>
      <th>Function</th>
      <th>Type Conversion</th>
    </tr>
  </thead>
 <tr>
    <td>%o</td>
    <td>Displays as expandable DOM element</<td>
    <td>n/a</td>
  </tr>
  <tr>
    <td>%O</td>
    <td>Displays as expandable JS Object</<td>
    <td>n/a</td>
  </tr>
  <tr>
    <td>%c</td>
    <td>Applies provided CSS</<td>
    <td>n/a</td>
  </tr>
</table>

<h2 id="inspection">JavaScript Object inspection</h2>

TODO: Define an interface that allows JavaScript objects to format themselves for inspection.

<h2 id="acks" class="no-num">Acknowledgments</h2>
